#!/usr/bin/env tsx
/**
 * Generate React Query hooks from OpenAPI spec
 *
 * This script generates TanStack Query (React Query) hooks for all endpoints.
 * Each endpoint gets a useQuery hook (GET) or useMutation hook (POST/PUT/DELETE).
 */

import { readFileSync, writeFileSync, mkdirSync } from 'fs'
import { resolve } from 'path'

const OPENAPI_SPEC_PATH = resolve(__dirname, '../lib/frontend-api-v2-openapi.json')
const OUTPUT_FILE = resolve(__dirname, '../lib/api/generated-hooks.ts')

interface OpenAPISpec {
  paths: Record<string, Record<string, {
    operationId?: string
    summary?: string
    parameters?: Array<{ name: string; in: string; required?: boolean }>
    requestBody?: { content: Record<string, { schema: unknown }> }
    security?: Array<Record<string, string[]>>
  }>>
  servers: Array<{ url: string }>
}

console.log('ðŸ”„ Generating React Query hooks from OpenAPI spec...')

try {
  // Ensure output directory exists
  mkdirSync(resolve(__dirname, '../lib/api'), { recursive: true })

  // Read OpenAPI spec
  const spec: OpenAPISpec = JSON.parse(readFileSync(OPENAPI_SPEC_PATH, 'utf-8'))
  const baseUrl = spec.servers[0]?.url || ''

  let hooksCode = `/**
 * Auto-generated React Query hooks for Frontend API v2
 * Generated from: ${OPENAPI_SPEC_PATH}
 * Base URL: ${baseUrl}
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * Run 'npm run hooks:gen' to regenerate
 */

import { useQuery, useMutation, useQueryClient, QueryClient } from '@tanstack/react-query'
import type { UseQueryOptions, UseMutationOptions } from '@tanstack/react-query'
import { api } from './client'
import type { paths } from './generated-types'

`

  const endpoints: Array<{ path: string; method: string; operationId: string; summary: string; requiresAuth: boolean }> = []

  // Parse all endpoints
  for (const [path, methods] of Object.entries(spec.paths)) {
    for (const [method, operation] of Object.entries(methods)) {
      const operationId = operation.operationId || `${method}_${path.replace(/\//g, '_')}`
      const summary = operation.summary || `${method.toUpperCase()} ${path}`
      const requiresAuth = !!(operation.security && operation.security.length > 0)

      endpoints.push({ path, method: method.toUpperCase(), operationId, summary, requiresAuth })
    }
  }

  console.log(`ðŸ“Š Found ${endpoints.length} endpoints`)

  // Track generated hook names to avoid duplicates
  const usedHookNames = new Set<string>()

  // Generate hooks for each endpoint
  for (const endpoint of endpoints) {
    let hookName = generateHookName(endpoint.path, endpoint.method)
    const queryKey = generateQueryKey(endpoint.path)

    // If this hook name is already used, make it unique
    let uniqueHookName = hookName
    let counter = 1
    while (usedHookNames.has(uniqueHookName)) {
      // Try adding method suffix first
      if (counter === 1) {
        uniqueHookName = hookName + endpoint.method.charAt(0) + endpoint.method.slice(1).toLowerCase()
      } else {
        // If that's also taken, add a number
        uniqueHookName = hookName + counter
      }
      counter++
    }
    usedHookNames.add(uniqueHookName)
    hookName = uniqueHookName

    if (endpoint.method === 'GET') {
      // Generate useQuery hook
      hooksCode += `
/**
 * ${endpoint.summary}
 * ${endpoint.method} ${endpoint.path}
 */
export function ${hookName}(
  params?: Record<string, any>,
  options?: Omit<UseQueryOptions<any>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: ['${queryKey}', params],
    queryFn: () => api.get('${endpoint.path}', { params }),
    ...options,
  })
}
`
    } else {
      // Generate useMutation hook
      hooksCode += `
/**
 * ${endpoint.summary}
 * ${endpoint.method} ${endpoint.path}
 */
export function ${hookName}(
  options?: UseMutationOptions<any, Error, any>
) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (data: any) => api.${endpoint.method.toLowerCase()}('${endpoint.path}', data),
    onSuccess: () => {
      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: ['${queryKey}'] })
    },
    ...options,
  })
}
`
    }
  }

  // Write generated code
  writeFileSync(OUTPUT_FILE, hooksCode, 'utf-8')

  console.log('âœ… React Query hooks generated successfully!')
  console.log(`ðŸ“Š Generated ${endpoints.length} hooks`)
  console.log(`ðŸ“ Output: ${OUTPUT_FILE}`)
} catch (error) {
  console.error('âŒ Failed to generate hooks:', error)
  process.exit(1)
}

function generateHookName(path: string, method: string): string {
  // Convert /admin/resync-user to useAdminResyncUser (for POST)
  // Convert /chart/revenue-trends to useChartRevenueTrends (for GET)
  const parts = path
    .split('/')
    .filter(p => p && !p.startsWith('{'))
    .map(p => p.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase()))
    .map(p => p.charAt(0).toUpperCase() + p.slice(1))

  const prefix = method === 'GET' ? 'use' :
                 method === 'POST' ? 'useCreate' :
                 method === 'PUT' ? 'useUpdate' :
                 method === 'DELETE' ? 'useDelete' : 'use'

  return prefix + parts.join('')
}

function generateQueryKey(path: string): string {
  // Convert /admin/resync-user to admin-resync-user
  return path.replace(/^\//, '').replace(/\//g, '-')
}
