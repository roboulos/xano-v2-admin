#!/usr/bin/env tsx
/**
 * Generate Zod schemas from OpenAPI spec
 *
 * This script generates Zod schemas for runtime validation of API responses.
 * Provides type safety at runtime, catching API changes that TypeScript can't detect.
 */

import { readFileSync, writeFileSync, mkdirSync } from 'fs'
import { resolve } from 'path'

const OPENAPI_SPEC_PATH = resolve(__dirname, '../lib/frontend-api-v2-openapi.json')
const OUTPUT_FILE = resolve(__dirname, '../lib/api/generated-schemas.ts')

interface OpenAPISchema {
  type?: string
  properties?: Record<string, OpenAPISchema>
  items?: OpenAPISchema
  required?: string[]
  enum?: any[]
}

interface OpenAPISpec {
  paths: Record<string, Record<string, {
    operationId?: string
    responses?: Record<string, {
      content?: Record<string, { schema?: OpenAPISchema }>
    }>
  }>>
}

console.log('ðŸ”„ Generating Zod schemas from OpenAPI spec...')

try {
  // Ensure output directory exists
  mkdirSync(resolve(__dirname, '../lib/api'), { recursive: true })

  // Read OpenAPI spec
  const spec: OpenAPISpec = JSON.parse(readFileSync(OPENAPI_SPEC_PATH, 'utf-8'))

  let schemasCode = `/**
 * Auto-generated Zod schemas for Frontend API v2
 * Generated from: ${OPENAPI_SPEC_PATH}
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * Run 'npm run schemas:gen' to regenerate
 */

import { z } from 'zod'

`

  const generatedSchemas = new Set<string>()
  let schemaCount = 0

  // Generate schemas for each endpoint response
  for (const [path, methods] of Object.entries(spec.paths)) {
    for (const [method, operation] of Object.entries(methods)) {
      const operationId = operation.operationId || `${method}_${path.replace(/\//g, '_')}`
      const schemaName = generateSchemaName(operationId)

      // Skip if already generated
      if (generatedSchemas.has(schemaName)) continue

      // Get 200 response schema
      const response200 = operation.responses?.['200']
      const schema = response200?.content?.['application/json']?.schema

      if (schema) {
        const zodSchema = convertToZodSchema(schema, 0)
        schemasCode += `
/**
 * Schema for ${operationId}
 * ${method.toUpperCase()} ${path}
 */
export const ${schemaName} = ${zodSchema}

export type ${schemaName}Type = z.infer<typeof ${schemaName}>
`
        generatedSchemas.add(schemaName)
        schemaCount++
      }
    }
  }

  // Write generated code
  writeFileSync(OUTPUT_FILE, schemasCode, 'utf-8')

  console.log('âœ… Zod schemas generated successfully!')
  console.log(`ðŸ“Š Generated ${schemaCount} schemas`)
  console.log(`ðŸ“ Output: ${OUTPUT_FILE}`)
} catch (error) {
  console.error('âŒ Failed to generate schemas:', error)
  process.exit(1)
}

function generateSchemaName(operationId: string): string {
  // Convert operationId to PascalCase and add Schema suffix
  return operationId
    .split(/[^a-zA-Z0-9]/)
    .filter(p => p)
    .map(p => p.charAt(0).toUpperCase() + p.slice(1))
    .join('') + 'Schema'
}

function convertToZodSchema(schema: OpenAPISchema, depth: number): string {
  if (depth > 10) return 'z.any()' // Prevent infinite recursion

  if (schema.enum) {
    const values = schema.enum.map(v => JSON.stringify(v)).join(', ')
    return `z.enum([${values}])`
  }

  switch (schema.type) {
    case 'string':
      return 'z.string()'
    case 'number':
    case 'integer':
      return 'z.number()'
    case 'boolean':
      return 'z.boolean()'
    case 'array':
      if (schema.items) {
        return `z.array(${convertToZodSchema(schema.items, depth + 1)})`
      }
      return 'z.array(z.any())'
    case 'object':
      if (schema.properties) {
        const props = Object.entries(schema.properties)
          .map(([key, prop]) => {
            const isRequired = schema.required?.includes(key)
            const zodType = convertToZodSchema(prop, depth + 1)
            return `  ${key}: ${zodType}${isRequired ? '' : '.optional()'}`
          })
          .join(',\n')
        return `z.object({\n${props}\n})`
      }
      return 'z.record(z.any())'
    default:
      return 'z.any()'
  }
}
