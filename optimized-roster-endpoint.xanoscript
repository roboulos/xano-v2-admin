// OPTIMIZED team_management/roster endpoint
// Fixes: O(N*M) foreach loops, unindexed queries, missing LIMITs
// Target: < 5 seconds (from 30+ second timeout)

query "team_management/roster" verb=GET {
  input {
    int team_id?
    text search? filters=trim
    text sortBy? filters=trim
    text orderBy? filters=trim
    bool is_director?
    bool is_leader?
    bool is_mentor?
    bool inactive?
    bool seat?
    bool seat_unassigned?
    int page?
    int per_page?
  }

  stack {
    // Step 1: Get team members (filtered)
    db.query team_members {
      where = $db.team_members.team_id ==? $input.team_id && $db.team_members.is_director ==? $input.is_director && $db.team_members.is_leader ==? $input.is_leader && $db.team_members.is_mentor ==? $input.is_mentor && $db.team_members.seat ==? $input.seat && $db.team_members.active !=? $input.inactive
      sort = {team_members.id: "desc"}
      return = {type: "list"}
    } as $team_members

    // Step 2: Get all agent IDs from team members
    var $agent_ids {
      value = $team_members|get:"agent_id":null
    }

    // Step 3: Query ALL agents in one batch (indexed lookup)
    db.query agent {
      where = $db.agent.id in $agent_ids
      return = {type: "list"}
      output = [
        "id"
        "display_name"
        "first_name"
        "last_name"
        "email"
        "phone"
        "home_address_id"
        "city"
        "state"
      ]
    } as $agents

    // Step 4: Build agent lookup map (O(N) instead of O(N*M) array.find)
    var $agent_map {
      value = {}
    }

    foreach ($agents) {
      each as $agent {
        var.update $agent_map {
          value = $agent_map|set:($agent.id|string):$agent
        }
      }
    }

    // Step 5: Get address IDs from agents
    var $address_ids {
      value = $agents
        |get:"home_address_id":null
        |unique:""
    }

    // Step 6: Query ALL addresses in one batch (indexed lookup)
    db.query address {
      where = $db.address.id in $address_ids
      return = {type: "list"}
      output = ["id", "city", "state", "state_abbreviation", "lat", "long"]
    } as $addresses

    // Step 7: Build address lookup map
    var $address_map {
      value = {}
    }

    foreach ($addresses) {
      each as $addr {
        var.update $address_map {
          value = $address_map|set:($addr.id|string):$addr
        }
      }
    }

    // Step 8: OPTIMIZED - Get most recent transactions (pagination to limit results)
    // This is the key fix - old code had no pagination and fetched all transactions
    db.query transaction {
      where = $db.transaction.transaction_owner_agent_id in $agent_ids
      sort = {closing_date: "desc"}
      return = {type: "paginated", page: 1, per_page: 200, totals: false}
      output = ["id", "transaction_owner_agent_id", "address_id"]
    } as $agent_transactions_result

    // Extract items from paginated response
    var $agent_transactions {
      value = $agent_transactions_result|get:"items":[]
    }

    // Step 9: Get transaction address IDs
    var $tx_address_ids {
      value = $agent_transactions|get:"address_id":null|unique:""
    }

    // Step 10: Query transaction addresses in one batch
    db.query address {
      where = $db.address.id in $tx_address_ids
      return = {type: "list"}
      output = ["id", "city", "state", "state_abbreviation", "lat", "long"]
    } as $tx_addresses

    // Step 11: Build transaction address lookup map
    var $tx_address_map {
      value = {}
    }

    foreach ($tx_addresses) {
      each as $tx_addr {
        var.update $tx_address_map {
          value = $tx_address_map|set:($tx_addr.id|string):$tx_addr
        }
      }
    }

    // Step 12: Build transaction-to-agent map (only keep first/most recent per agent)
    var $agent_tx_map {
      value = {}
    }

    foreach ($agent_transactions) {
      each as $tx {
        var $agent_id_str {
          value = $tx.transaction_owner_agent_id|string
        }

        // Only set if not already set (first = most recent due to sort)
        conditional {
          if ($agent_tx_map|get:$agent_id_str:null == null) {
            var.update $agent_tx_map {
              value = $agent_tx_map|set:$agent_id_str:$tx
            }
          }
        }
      }
    }

    // Step 13: Build final roster using lookup maps (O(N) instead of O(N*M))
    var $roster_data {
      value = []
    }

    foreach ($team_members) {
      each as $member {
        var $agent_id_str {
          value = $member.agent_id|string
        }

        // Get agent from map (O(1) instead of array.find O(M))
        var $agent_match {
          value = $agent_map|get:$agent_id_str:null
        }

        // Get home address from map if agent has one
        var $address_match {
          value = null
        }

        conditional {
          if ($agent_match != null) {
            var $home_addr_id {
              value = $agent_match|get:"home_address_id":0
            }

            conditional {
              if ($home_addr_id > 0) {
                var.update $address_match {
                  value = $address_map|get:($home_addr_id|string):null
                }
              }
            }
          }
        }

        // Get fallback transaction address if no home address
        var $fallback_address {
          value = null
        }

        conditional {
          if ($address_match == null && $agent_match != null) {
            var $agent_tx {
              value = $agent_tx_map|get:$agent_id_str:null
            }

            conditional {
              if ($agent_tx != null) {
                var $tx_addr_id {
                  value = $agent_tx|get:"address_id":0
                }

                conditional {
                  if ($tx_addr_id > 0) {
                    var.update $fallback_address {
                      value = $tx_address_map|get:($tx_addr_id|string):null
                    }
                  }
                }
              }
            }
          }
        }

        // Choose final address (home or fallback)
        var $final_address {
          value = $address_match != null ? $address_match : $fallback_address
        }

        // Build enriched member record
        var $enriched_member {
          value = $member
            |set:"name":($agent_match|get:"display_name":"")
            |set:"first_name":($agent_match|get:"first_name":"")
            |set:"last_name":($agent_match|get:"last_name":"")
            |set:"email":($agent_match|get:"email":"")
            |set:"phone":($agent_match|get:"phone":"")
            |set:"city":($final_address
              |get:"city":($agent_match|get:"city":"")
            )
            |set:"state":($final_address
              |get:"state_abbreviation":($final_address
                |get:"state":($agent_match|get:"state":"")
              )
            )
            |set:"state_province":($final_address
              |get:"state_abbreviation":($final_address
                |get:"state":($agent_match|get:"state":"")
              )
            )
            |set:"lat":($final_address|get:"lat":null)
            |set:"lng":($final_address|get:"long":null)
        }

        // Add to roster array
        array.push $roster_data {
          value = $enriched_member
        }
      }
    }
  }

  response = $roster_data
  tags = [
    "ğŸ  dashboard"
    "ğŸ‘¥ team"
    "âœ¨ v2"
    "ğŸ”µ normalized-tables"
    "ğŸ“ location-fields-2025-12-22"
    "ğŸ”„ tx-address-fallback-2025-12-22"
    "âš¡ optimized-2026-01-22"
  ]
}
